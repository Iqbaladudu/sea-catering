{"version":3,"sources":["../../src/queries/parseParams.ts"],"sourcesContent":["import type { SQL, Table } from 'drizzle-orm'\nimport type { FlattenedField, Operator, Sort, Where } from 'payload'\n\nimport { and, isNotNull, isNull, ne, notInArray, or, sql } from 'drizzle-orm'\nimport { PgUUID } from 'drizzle-orm/pg-core'\nimport { QueryError } from 'payload'\nimport { validOperatorSet } from 'payload/shared'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\nimport { buildAndOrConditions } from './buildAndOrConditions.js'\nimport { getTableColumnFromPath } from './getTableColumnFromPath.js'\nimport { sanitizeQueryValue } from './sanitizeQueryValue.js'\n\nexport type QueryContext = { rawSort?: SQL; sort: Sort }\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: Table\n  context: QueryContext\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  parentIsLocalized: boolean\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  where: Where\n}\n\nexport function parseParams({\n  adapter,\n  aliasTable,\n  context,\n  fields,\n  joins,\n  locale,\n  parentIsLocalized,\n  selectFields,\n  selectLocale,\n  tableName,\n  where,\n}: Args): SQL {\n  let result: SQL\n  const constraints: SQL[] = []\n\n  if (typeof where === 'object' && Object.keys(where).length > 0) {\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    for (const relationOrPath of Object.keys(where)) {\n      if (relationOrPath) {\n        const condition = where[relationOrPath]\n        let conditionOperator: typeof and | typeof or\n        if (relationOrPath.toLowerCase() === 'and') {\n          conditionOperator = and\n        } else if (relationOrPath.toLowerCase() === 'or') {\n          conditionOperator = or\n        }\n        if (Array.isArray(condition)) {\n          const builtConditions = buildAndOrConditions({\n            adapter,\n            aliasTable,\n            context,\n            fields,\n            joins,\n            locale,\n            parentIsLocalized,\n            selectFields,\n            selectLocale,\n            tableName,\n            where: condition,\n          })\n          if (builtConditions.length > 0) {\n            result = conditionOperator(...builtConditions)\n          }\n        } else {\n          // It's a path - and there can be multiple comparisons on a single path.\n          // For example - title like 'test' and title not equal to 'tester'\n          // So we need to loop on keys again here to handle each operator independently\n          const pathOperators = where[relationOrPath]\n          if (typeof pathOperators === 'object') {\n            for (let operator of Object.keys(pathOperators)) {\n              if (validOperatorSet.has(operator as Operator)) {\n                const val = where[relationOrPath][operator]\n\n                const {\n                  columnName,\n                  columns,\n                  constraints: queryConstraints,\n                  field,\n                  getNotNullColumnByValue,\n                  pathSegments,\n                  rawColumn,\n                  table,\n                } = getTableColumnFromPath({\n                  adapter,\n                  aliasTable,\n                  collectionPath: relationOrPath,\n                  fields,\n                  joins,\n                  locale,\n                  parentIsLocalized,\n                  pathSegments: relationOrPath.replace(/__/g, '.').split('.'),\n                  selectFields,\n                  selectLocale,\n                  tableName,\n                  value: val,\n                })\n\n                queryConstraints.forEach(({ columnName: col, table: constraintTable, value }) => {\n                  if (typeof value === 'string' && value.indexOf('%') > -1) {\n                    constraints.push(adapter.operators.like(constraintTable[col], value))\n                  } else {\n                    constraints.push(adapter.operators.equals(constraintTable[col], value))\n                  }\n                })\n\n                if (\n                  (['json', 'richText'].includes(field.type) ||\n                    (field.type === 'blocks' && adapter.blocksAsJSON)) &&\n                  Array.isArray(pathSegments) &&\n                  pathSegments.length > 1\n                ) {\n                  if (adapter.name === 'postgres') {\n                    const constraint = adapter.createJSONQuery({\n                      column: rawColumn || table[columnName],\n                      operator,\n                      pathSegments,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(constraint))\n                    break\n                  }\n\n                  const segments = pathSegments.slice(1)\n                  segments.unshift(table[columnName].name)\n\n                  if (field.type === 'richText') {\n                    // use the table name from the nearest join to handle blocks, arrays, etc. or use the tableName arg\n                    const jsonTable =\n                      joins.length === 0\n                        ? tableName\n                        : joins[joins.length - 1].table[\n                            Object.getOwnPropertySymbols(joins[joins.length - 1].table)[0]\n                          ]\n                    const jsonQuery = adapter.createJSONQuery({\n                      operator,\n                      pathSegments: segments,\n                      table: jsonTable,\n                      treatAsArray: ['children'],\n                      treatRootAsArray: true,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(jsonQuery))\n                    break\n                  }\n\n                  const jsonQuery = adapter.convertPathToJSONTraversal(pathSegments)\n                  const operatorKeys: Record<string, { operator: string; wildcard: string }> = {\n                    contains: { operator: 'like', wildcard: '%' },\n                    equals: { operator: '=', wildcard: '' },\n                    exists: { operator: val === true ? 'is not null' : 'is null', wildcard: '' },\n                    in: { operator: 'in', wildcard: '' },\n                    like: { operator: 'like', wildcard: '%' },\n                    not_equals: { operator: '<>', wildcard: '' },\n                    not_in: { operator: 'not in', wildcard: '' },\n                    not_like: { operator: 'not like', wildcard: '%' },\n                  }\n\n                  let formattedValue = val\n                  if (adapter.name === 'sqlite' && operator === 'equals' && !isNaN(val)) {\n                    formattedValue = val\n                  } else if (['in', 'not_in'].includes(operator) && Array.isArray(val)) {\n                    formattedValue = `(${val.map((v) => `${v}`).join(',')})`\n                  } else {\n                    formattedValue = `'${operatorKeys[operator].wildcard}${val}${operatorKeys[operator].wildcard}'`\n                  }\n                  if (operator === 'exists') {\n                    formattedValue = ''\n                  }\n\n                  let jsonQuerySelector = `${table[columnName].name}${jsonQuery}`\n\n                  if (adapter.name === 'sqlite' && operator === 'not_like') {\n                    jsonQuerySelector = `COALESCE(${table[columnName].name}${jsonQuery}, '')`\n                  }\n\n                  const rawSQLQuery = `${jsonQuerySelector} ${operatorKeys[operator].operator} ${formattedValue}`\n\n                  constraints.push(sql.raw(rawSQLQuery))\n\n                  break\n                }\n\n                if (getNotNullColumnByValue) {\n                  const columnName = getNotNullColumnByValue(val)\n                  if (columnName) {\n                    constraints.push(isNotNull(table[columnName]))\n                  } else {\n                    throw new QueryError([{ path: relationOrPath }])\n                  }\n                  break\n                }\n\n                if (\n                  operator === 'like' &&\n                  (field.type === 'number' || table[columnName].columnType === 'PgUUID')\n                ) {\n                  operator = 'equals'\n                }\n\n                if (operator === 'like') {\n                  constraints.push(\n                    and(\n                      ...val\n                        .split(' ')\n                        .map((word) => adapter.operators.like(table[columnName], `%${word}%`)),\n                    ),\n                  )\n                  break\n                }\n\n                const sanitizedQueryValue = sanitizeQueryValue({\n                  adapter,\n                  columns,\n                  field,\n                  isUUID: table?.[columnName] instanceof PgUUID,\n                  operator,\n                  relationOrPath,\n                  val,\n                })\n\n                if (sanitizedQueryValue === null) {\n                  break\n                }\n\n                const {\n                  columns: queryColumns,\n                  operator: queryOperator,\n                  value: queryValue,\n                } = sanitizedQueryValue\n\n                // Handle polymorphic relationships by value\n                if (queryColumns) {\n                  if (!queryColumns.length) {\n                    break\n                  }\n\n                  let wrapOperator = or\n\n                  if (queryValue === null && ['equals', 'not_equals'].includes(operator)) {\n                    if (operator === 'equals') {\n                      wrapOperator = and\n                    }\n\n                    constraints.push(\n                      wrapOperator(\n                        ...queryColumns.map(({ rawColumn }) =>\n                          operator === 'equals' ? isNull(rawColumn) : isNotNull(rawColumn),\n                        ),\n                      ),\n                    )\n                    break\n                  }\n\n                  if (['not_equals', 'not_in'].includes(operator)) {\n                    wrapOperator = and\n                  }\n\n                  constraints.push(\n                    wrapOperator(\n                      ...queryColumns.map(({ rawColumn, value }) =>\n                        adapter.operators[queryOperator](rawColumn, value),\n                      ),\n                    ),\n                  )\n\n                  break\n                }\n\n                const resolvedColumn =\n                  rawColumn ||\n                  (aliasTable && tableName === getNameFromDrizzleTable(table)\n                    ? aliasTable[columnName]\n                    : table[columnName])\n\n                if (queryOperator === 'not_equals' && queryValue !== null) {\n                  constraints.push(\n                    or(\n                      isNull(resolvedColumn),\n                      /* eslint-disable @typescript-eslint/no-explicit-any */\n                      ne<any>(resolvedColumn, queryValue),\n                    ),\n                  )\n                  break\n                }\n\n                if (\n                  (field.type === 'relationship' || field.type === 'upload') &&\n                  Array.isArray(queryValue) &&\n                  operator === 'not_in'\n                ) {\n                  constraints.push(\n                    sql`(${notInArray(table[columnName], queryValue)} OR\n                    ${table[columnName]}\n                    IS\n                    NULL)`,\n                  )\n\n                  break\n                }\n\n                if (operator === 'equals' && queryValue === null) {\n                  constraints.push(isNull(resolvedColumn))\n                  break\n                }\n\n                if (operator === 'not_equals' && queryValue === null) {\n                  constraints.push(isNotNull(resolvedColumn))\n                  break\n                }\n\n                if (field.type === 'point' && adapter.name === 'postgres') {\n                  switch (operator) {\n                    case 'intersects': {\n                      constraints.push(\n                        sql`ST_Intersects(${table[columnName]}, ST_GeomFromGeoJSON(${JSON.stringify(queryValue)}))`,\n                      )\n                      break\n                    }\n\n                    case 'near': {\n                      const [lng, lat, maxDistance, minDistance] = queryValue as number[]\n                      const geoConstraints: SQL[] = []\n\n                      if (typeof maxDistance === 'number' && !Number.isNaN(maxDistance)) {\n                        geoConstraints.push(\n                          sql`ST_DWithin(ST_Transform(${table[columnName]}, 3857), ST_Transform(ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326), 3857), ${maxDistance})`,\n                        )\n                      }\n\n                      if (typeof minDistance === 'number' && !Number.isNaN(minDistance)) {\n                        geoConstraints.push(\n                          sql`ST_Distance(ST_Transform(${table[columnName]}, 3857), ST_Transform(ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326), 3857)) >= ${minDistance}`,\n                        )\n                      }\n                      if (geoConstraints.length) {\n                        context.sort = relationOrPath\n                        context.rawSort = sql`${table[columnName]} <-> ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326)`\n                        constraints.push(and(...geoConstraints))\n                      }\n                      break\n                    }\n\n                    case 'within': {\n                      constraints.push(\n                        sql`ST_Within(${table[columnName]}, ST_GeomFromGeoJSON(${JSON.stringify(queryValue)}))`,\n                      )\n                      break\n                    }\n\n                    default:\n                      break\n                  }\n                  break\n                }\n\n                const orConditions: SQL<unknown>[] = []\n                let resolvedQueryValue = queryValue\n                if (\n                  operator === 'in' &&\n                  Array.isArray(queryValue) &&\n                  queryValue.some((v) => v === null)\n                ) {\n                  orConditions.push(isNull(resolvedColumn))\n                  resolvedQueryValue = queryValue.filter((v) => v !== null)\n                }\n                let constraint = adapter.operators[queryOperator](\n                  resolvedColumn,\n                  resolvedQueryValue,\n                )\n                if (orConditions.length) {\n                  orConditions.push(constraint)\n                  constraint = or(...orConditions)\n                }\n                constraints.push(constraint)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (constraints.length > 0) {\n    if (result) {\n      result = and(result, ...constraints)\n    } else {\n      result = and(...constraints)\n    }\n  }\n  if (constraints.length === 1 && !result) {\n    ;[result] = constraints\n  }\n\n  return result\n}\n"],"names":["and","isNotNull","isNull","ne","notInArray","or","sql","PgUUID","QueryError","validOperatorSet","getNameFromDrizzleTable","buildAndOrConditions","getTableColumnFromPath","sanitizeQueryValue","parseParams","adapter","aliasTable","context","fields","joins","locale","parentIsLocalized","selectFields","selectLocale","tableName","where","result","constraints","Object","keys","length","relationOrPath","condition","conditionOperator","toLowerCase","Array","isArray","builtConditions","pathOperators","operator","has","val","columnName","columns","queryConstraints","field","getNotNullColumnByValue","pathSegments","rawColumn","table","collectionPath","replace","split","value","forEach","col","constraintTable","indexOf","push","operators","like","equals","includes","type","blocksAsJSON","name","constraint","createJSONQuery","column","raw","segments","slice","unshift","jsonTable","getOwnPropertySymbols","jsonQuery","treatAsArray","treatRootAsArray","convertPathToJSONTraversal","operatorKeys","contains","wildcard","exists","in","not_equals","not_in","not_like","formattedValue","isNaN","map","v","join","jsonQuerySelector","rawSQLQuery","path","columnType","word","sanitizedQueryValue","isUUID","queryColumns","queryOperator","queryValue","wrapOperator","resolvedColumn","JSON","stringify","lng","lat","maxDistance","minDistance","geoConstraints","Number","sort","rawSort","orConditions","resolvedQueryValue","some","filter"],"mappings":"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"}