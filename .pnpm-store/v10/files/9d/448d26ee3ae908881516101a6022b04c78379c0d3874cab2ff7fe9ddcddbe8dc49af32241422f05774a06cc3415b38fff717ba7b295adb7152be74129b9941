{"version":3,"sources":["../../../../src/queues/operations/runJobs/index.ts"],"sourcesContent":["import type { PayloadRequest, Sort, Where } from '../../../types/index.js'\nimport type { WorkflowJSON } from '../../config/types/workflowJSONTypes.js'\nimport type {\n  BaseJob,\n  WorkflowConfig,\n  WorkflowHandler,\n  WorkflowTypes,\n} from '../../config/types/workflowTypes.js'\nimport type { RunJobResult } from './runJob/index.js'\n\nimport { Forbidden } from '../../../errors/Forbidden.js'\nimport isolateObjectProperty from '../../../utilities/isolateObjectProperty.js'\nimport { jobsCollectionSlug } from '../../config/index.js'\nimport { updateJob, updateJobs } from '../../utilities/updateJob.js'\nimport { getUpdateJobFunction } from './runJob/getUpdateJobFunction.js'\nimport { importHandlerPath } from './runJob/importHandlerPath.js'\nimport { runJob } from './runJob/index.js'\nimport { runJSONJob } from './runJSONJob/index.js'\n\nexport type RunJobsArgs = {\n  /**\n   * If you want to run jobs from all queues, set this to true.\n   * If you set this to true, the `queue` property will be ignored.\n   *\n   * @default false\n   */\n  allQueues?: boolean\n  /**\n   * ID of the job to run\n   */\n  id?: number | string\n  /**\n   * The maximum number of jobs to run in this invocation\n   *\n   * @default 10\n   */\n  limit?: number\n  overrideAccess?: boolean\n  /**\n   * Adjust the job processing order\n   *\n   * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.\n   *\n   * @default all jobs for all queues will be executed in FIFO order.\n   */\n  processingOrder?: Sort\n  /**\n   * If you want to run jobs from a specific queue, set this to the queue name.\n   *\n   * @default jobs from the `default` queue will be executed.\n   */\n  queue?: string\n  req: PayloadRequest\n  /**\n   * By default, jobs are run in parallel.\n   * If you want to run them in sequence, set this to true.\n   */\n  sequential?: boolean\n  where?: Where\n}\n\nexport type RunJobsResult = {\n  jobStatus?: Record<string, RunJobResult>\n  /**\n   * If this is false, there for sure are no jobs remaining, regardless of the limit\n   */\n  noJobsRemaining?: boolean\n  /**\n   * Out of the jobs that were queried & processed (within the set limit), how many are remaining and retryable?\n   */\n  remainingJobsFromQueried: number\n}\n\nexport const runJobs = async (args: RunJobsArgs): Promise<RunJobsResult> => {\n  const {\n    id,\n    allQueues = false,\n    limit = 10,\n    overrideAccess,\n    processingOrder,\n    queue = 'default',\n    req,\n    req: {\n      payload,\n      payload: {\n        config: { jobs: jobsConfig },\n      },\n    },\n    sequential,\n    where: whereFromProps,\n  } = args\n\n  if (!overrideAccess) {\n    const accessFn = jobsConfig?.access?.run ?? (() => true)\n    const hasAccess = await accessFn({ req })\n    if (!hasAccess) {\n      throw new Forbidden(req.t)\n    }\n  }\n  const where: Where = {\n    and: [\n      {\n        completedAt: {\n          exists: false,\n        },\n      },\n      {\n        hasError: {\n          not_equals: true,\n        },\n      },\n      {\n        processing: {\n          equals: false,\n        },\n      },\n      {\n        or: [\n          {\n            waitUntil: {\n              exists: false,\n            },\n          },\n          {\n            waitUntil: {\n              less_than: new Date().toISOString(),\n            },\n          },\n        ],\n      },\n    ],\n  }\n\n  if (allQueues !== true) {\n    where.and?.push({\n      queue: {\n        equals: queue ?? 'default',\n      },\n    })\n  }\n\n  if (whereFromProps) {\n    where.and?.push(whereFromProps)\n  }\n\n  // Find all jobs and ensure we set job to processing: true as early as possible to reduce the chance of\n  // the same job being picked up by another worker\n  const jobsQuery: {\n    docs: BaseJob[]\n  } = { docs: [] }\n\n  if (id) {\n    // Only one job to run\n    jobsQuery.docs = [\n      (await updateJob({\n        id,\n        data: {\n          processing: true,\n        },\n        depth: jobsConfig.depth,\n        disableTransaction: true,\n        req,\n        returning: true,\n      }))!,\n    ]\n  } else {\n    let defaultProcessingOrder: Sort =\n      payload.collections[jobsCollectionSlug]?.config.defaultSort ?? 'createdAt'\n\n    const processingOrderConfig = jobsConfig?.processingOrder\n    if (typeof processingOrderConfig === 'function') {\n      defaultProcessingOrder = await processingOrderConfig(args)\n    } else if (typeof processingOrderConfig === 'object' && !Array.isArray(processingOrderConfig)) {\n      if (\n        !allQueues &&\n        queue &&\n        processingOrderConfig.queues &&\n        processingOrderConfig.queues[queue]\n      ) {\n        defaultProcessingOrder = processingOrderConfig.queues[queue]\n      } else if (processingOrderConfig.default) {\n        defaultProcessingOrder = processingOrderConfig.default\n      }\n    } else if (typeof processingOrderConfig === 'string') {\n      defaultProcessingOrder = processingOrderConfig\n    }\n    const updatedDocs = await updateJobs({\n      data: {\n        processing: true,\n      },\n      depth: jobsConfig.depth,\n      disableTransaction: true,\n      limit,\n      req,\n      returning: true,\n      sort: processingOrder ?? defaultProcessingOrder,\n      where,\n    })\n\n    if (updatedDocs) {\n      jobsQuery.docs = updatedDocs\n    }\n  }\n\n  /**\n   * Just for logging purposes, we want to know how many jobs are new and how many are existing (= already been tried).\n   * This is only for logs - in the end we still want to run all jobs, regardless of whether they are new or existing.\n   */\n  const { existingJobs, newJobs } = jobsQuery.docs.reduce(\n    (acc, job) => {\n      if (job.totalTried > 0) {\n        acc.existingJobs.push(job)\n      } else {\n        acc.newJobs.push(job)\n      }\n      return acc\n    },\n    { existingJobs: [] as BaseJob[], newJobs: [] as BaseJob[] },\n  )\n\n  if (!jobsQuery.docs.length) {\n    return {\n      noJobsRemaining: true,\n      remainingJobsFromQueried: 0,\n    }\n  }\n\n  if (jobsQuery?.docs?.length) {\n    payload.logger.info({\n      msg: `Running ${jobsQuery.docs.length} jobs.`,\n      new: newJobs?.length,\n      retrying: existingJobs?.length,\n    })\n  }\n  const jobsToDelete: (number | string)[] | undefined = jobsConfig.deleteJobOnComplete\n    ? []\n    : undefined\n\n  const runSingleJob = async (job: BaseJob) => {\n    if (!job.workflowSlug && !job.taskSlug) {\n      throw new Error('Job must have either a workflowSlug or a taskSlug')\n    }\n    const jobReq = isolateObjectProperty(req, 'transactionID')\n\n    const workflowConfig: WorkflowConfig<WorkflowTypes> =\n      job.workflowSlug && jobsConfig.workflows?.length\n        ? jobsConfig.workflows.find(({ slug }) => slug === job.workflowSlug)!\n        : {\n            slug: 'singleTask',\n            handler: async ({ job, tasks }) => {\n              await tasks[job.taskSlug as string]!('1', {\n                input: job.input,\n              })\n            },\n          }\n\n    if (!workflowConfig) {\n      return null // Skip jobs with no workflow configuration\n    }\n\n    const updateJob = getUpdateJobFunction(job, jobReq)\n\n    // the runner will either be passed to the config\n    // OR it will be a path, which we will need to import via eval to avoid\n    // Next.js compiler dynamic import expression errors\n    let workflowHandler: WorkflowHandler<WorkflowTypes> | WorkflowJSON<WorkflowTypes>\n\n    if (\n      typeof workflowConfig.handler === 'function' ||\n      (typeof workflowConfig.handler === 'object' && Array.isArray(workflowConfig.handler))\n    ) {\n      workflowHandler = workflowConfig.handler\n    } else {\n      workflowHandler = await importHandlerPath<typeof workflowHandler>(workflowConfig.handler)\n\n      if (!workflowHandler) {\n        const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`\n        const errorMessage = `Can't find runner while importing with the path ${workflowConfig.handler} in job type ${jobLabel}.`\n        payload.logger.error(errorMessage)\n\n        await updateJob({\n          error: {\n            error: errorMessage,\n          },\n          hasError: true,\n          processing: false,\n        })\n\n        return\n      }\n    }\n\n    if (typeof workflowHandler === 'function') {\n      const result = await runJob({\n        job,\n        req: jobReq,\n        updateJob,\n        workflowConfig,\n        workflowHandler,\n      })\n\n      if (result.status !== 'error' && jobsToDelete) {\n        jobsToDelete.push(job.id)\n      }\n\n      return { id: job.id, result }\n    } else {\n      const result = await runJSONJob({\n        job,\n        req: jobReq,\n        updateJob,\n        workflowConfig,\n        workflowHandler,\n      })\n\n      if (result.status !== 'error' && jobsToDelete) {\n        jobsToDelete.push(job.id)\n      }\n\n      return { id: job.id, result }\n    }\n  }\n\n  let resultsArray: { id: number | string; result: RunJobResult }[] = []\n  if (sequential) {\n    for (const job of jobsQuery.docs) {\n      const result = await runSingleJob(job)\n      if (result !== null) {\n        resultsArray.push(result!)\n      }\n    }\n  } else {\n    const jobPromises = jobsQuery.docs.map(runSingleJob)\n    resultsArray = (await Promise.all(jobPromises)) as {\n      id: number | string\n      result: RunJobResult\n    }[]\n  }\n\n  if (jobsToDelete && jobsToDelete.length > 0) {\n    try {\n      if (jobsConfig.runHooks) {\n        await payload.delete({\n          collection: jobsCollectionSlug,\n          depth: 0, // can be 0 since we're not returning anything\n          disableTransaction: true,\n          where: { id: { in: jobsToDelete } },\n        })\n      } else {\n        await payload.db.deleteMany({\n          collection: jobsCollectionSlug,\n          where: { id: { in: jobsToDelete } },\n        })\n      }\n    } catch (err) {\n      payload.logger.error({\n        err,\n        msg: `failed to delete jobs ${jobsToDelete.join(', ')} on complete`,\n      })\n    }\n  }\n\n  const resultsObject: RunJobsResult['jobStatus'] = resultsArray.reduce(\n    (acc, cur) => {\n      if (cur !== null) {\n        // Check if there's a valid result to include\n        acc[cur.id] = cur.result\n      }\n      return acc\n    },\n    {} as Record<string, RunJobResult>,\n  )\n\n  let remainingJobsFromQueried = 0\n  for (const jobID in resultsObject) {\n    const jobResult = resultsObject[jobID]\n    if (jobResult?.status === 'error') {\n      remainingJobsFromQueried++ // Can be retried\n    }\n  }\n\n  return {\n    jobStatus: resultsObject,\n    remainingJobsFromQueried,\n  }\n}\n"],"names":["Forbidden","isolateObjectProperty","jobsCollectionSlug","updateJob","updateJobs","getUpdateJobFunction","importHandlerPath","runJob","runJSONJob","runJobs","args","id","allQueues","limit","overrideAccess","processingOrder","queue","req","payload","config","jobs","jobsConfig","sequential","where","whereFromProps","accessFn","access","run","hasAccess","t","and","completedAt","exists","hasError","not_equals","processing","equals","or","waitUntil","less_than","Date","toISOString","push","jobsQuery","docs","data","depth","disableTransaction","returning","defaultProcessingOrder","collections","defaultSort","processingOrderConfig","Array","isArray","queues","default","updatedDocs","sort","existingJobs","newJobs","reduce","acc","job","totalTried","length","noJobsRemaining","remainingJobsFromQueried","logger","info","msg","new","retrying","jobsToDelete","deleteJobOnComplete","undefined","runSingleJob","workflowSlug","taskSlug","Error","jobReq","workflowConfig","workflows","find","slug","handler","tasks","input","workflowHandler","jobLabel","errorMessage","error","result","status","resultsArray","jobPromises","map","Promise","all","runHooks","delete","collection","in","db","deleteMany","err","join","resultsObject","cur","jobID","jobResult","jobStatus"],"mappings":"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"}