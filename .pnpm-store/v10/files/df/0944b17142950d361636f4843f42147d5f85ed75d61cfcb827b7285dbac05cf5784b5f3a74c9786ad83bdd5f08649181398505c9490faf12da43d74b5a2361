{"version":3,"sources":["../../src/queries/getTableColumnFromPath.ts"],"sourcesContent":["import type { SQL } from 'drizzle-orm'\nimport type { SQLiteTableWithColumns } from 'drizzle-orm/sqlite-core'\nimport type {\n  FlattenedBlock,\n  FlattenedField,\n  NumberField,\n  RelationshipField,\n  TextField,\n} from 'payload'\n\nimport { and, eq, like, sql } from 'drizzle-orm'\nimport { type PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport { APIError, getFieldByPath } from 'payload'\nimport { fieldShouldBeLocalized, tabHasName } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\nimport { validate as uuidValidate } from 'uuid'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { isPolymorphicRelationship } from '../utilities/isPolymorphicRelationship.js'\nimport { resolveBlockTableName } from '../utilities/validateExistingBlockIsIdentical.js'\nimport { addJoinTable } from './addJoinTable.js'\nimport { getTableAlias } from './getTableAlias.js'\n\ntype Constraint = {\n  columnName: string\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  value: unknown\n}\n\ntype TableColumn = {\n  columnName?: string\n  columns?: {\n    idType: 'number' | 'text' | 'uuid'\n    rawColumn: SQL<unknown>\n  }[]\n  constraints: Constraint[]\n  field: FlattenedField\n  getNotNullColumnByValue?: (val: unknown) => string\n  pathSegments?: string[]\n  rawColumn?: SQL\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n}\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  collectionPath: string\n  columnPrefix?: string\n  constraintPath?: string\n  constraints?: Constraint[]\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  parentIsLocalized: boolean\n  pathSegments: string[]\n  rootTableName?: string\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  /**\n   * If creating a new table name for arrays and blocks, this suffix should be appended to the table name\n   */\n  tableNameSuffix?: string\n  /**\n   * The raw value of the query before sanitization\n   */\n  value: unknown\n}\n/**\n * Transforms path to table and column name or to a list of OR columns\n * Adds tables to `join`\n * @returns TableColumn\n */\nexport const getTableColumnFromPath = ({\n  adapter,\n  aliasTable,\n  collectionPath,\n  columnPrefix = '',\n  constraintPath: incomingConstraintPath,\n  constraints = [],\n  fields,\n  joins,\n  locale: incomingLocale,\n  parentIsLocalized,\n  pathSegments: incomingSegments,\n  rootTableName: incomingRootTableName,\n  selectFields,\n  selectLocale,\n  tableName,\n  tableNameSuffix = '',\n  value,\n}: Args): TableColumn => {\n  const fieldPath = incomingSegments[0]\n  let locale = incomingLocale\n  const rootTableName = incomingRootTableName || tableName\n  let constraintPath = incomingConstraintPath || ''\n\n  const field = fields.find((fieldToFind) => fieldToFind.name === fieldPath)\n  let newTableName = tableName\n\n  if (!field && fieldPath === 'id') {\n    selectFields.id = adapter.tables[newTableName].id\n    return {\n      columnName: 'id',\n      constraints,\n      field: {\n        name: 'id',\n        type: adapter.idType === 'uuid' ? 'text' : 'number',\n      } as NumberField | TextField,\n      table: adapter.tables[newTableName],\n    }\n  }\n\n  if (field) {\n    const pathSegments = [...incomingSegments]\n\n    const isFieldLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    // If next segment is a locale,\n    // we need to take it out and use it as the locale from this point on\n    if (isFieldLocalized && adapter.payload.config.localization) {\n      const matchedLocale = adapter.payload.config.localization.localeCodes.find(\n        (locale) => locale === pathSegments[1],\n      )\n\n      if (matchedLocale) {\n        locale = matchedLocale\n        pathSegments.splice(1, 1)\n      }\n    }\n\n    switch (field.type) {\n      case 'array': {\n        newTableName = adapter.tableNameMap.get(\n          `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n        )\n\n        const arrayParentTable = aliasTable || adapter.tables[tableName]\n\n        constraintPath = `${constraintPath}${field.name}.%.`\n        if (locale && isFieldLocalized && adapter.payload.config.localization) {\n          const conditions = [eq(arrayParentTable.id, adapter.tables[newTableName]._parentID)]\n\n          if (selectLocale) {\n            selectFields._locale = adapter.tables[newTableName]._locale\n          }\n\n          if (locale !== 'all') {\n            conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n          }\n          addJoinTable({\n            condition: and(...conditions),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        } else {\n          addJoinTable({\n            condition: eq(arrayParentTable.id, adapter.tables[newTableName]._parentID),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          collectionPath,\n          constraintPath,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          value,\n        })\n      }\n      case 'blocks': {\n        if (adapter.blocksAsJSON) {\n          break\n        }\n        let blockTableColumn: TableColumn\n        let newTableName: string\n\n        // handle blockType queries\n        if (pathSegments[1] === 'blockType') {\n          // find the block config using the value\n          const blockTypes = Array.isArray(value) ? value : [value]\n          blockTypes.forEach((blockType) => {\n            const block =\n              adapter.payload.blocks[blockType] ??\n              ((field.blockReferences ?? field.blocks).find(\n                (block) => typeof block !== 'string' && block.slug === blockType,\n              ) as FlattenedBlock | undefined)\n\n            newTableName = resolveBlockTableName(\n              block,\n              adapter.tableNameMap.get(`${tableName}_blocks_${toSnakeCase(block.slug)}`),\n            )\n\n            const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n            joins.push({\n              condition: eq(adapter.tables[tableName].id, newAliasTable._parentID),\n              table: newAliasTable,\n            })\n            constraints.push({\n              columnName: '_path',\n              table: newAliasTable,\n              value: pathSegments[0],\n            })\n          })\n          return {\n            constraints,\n            field,\n            getNotNullColumnByValue: () => 'id',\n            table: adapter.tables[tableName],\n          }\n        }\n\n        const hasBlockField = (field.blockReferences ?? field.blocks).some((_block) => {\n          const block = typeof _block === 'string' ? adapter.payload.blocks[_block] : _block\n\n          newTableName = resolveBlockTableName(\n            block,\n            adapter.tableNameMap.get(`${tableName}_blocks_${toSnakeCase(block.slug)}`),\n          )\n\n          constraintPath = `${constraintPath}${field.name}.%.`\n\n          let result: TableColumn\n          const blockConstraints = []\n          const blockSelectFields = {}\n\n          let blockJoin: BuildQueryJoinAliases[0]\n          if (isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            blockJoin = {\n              condition: and(...conditions),\n              table: adapter.tables[newTableName],\n            }\n          } else {\n            blockJoin = {\n              condition: eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n              table: adapter.tables[newTableName],\n            }\n          }\n\n          // Create a new reference for nested joins\n          const newJoins = [...joins]\n\n          try {\n            result = getTableColumnFromPath({\n              adapter,\n              collectionPath,\n              constraintPath,\n              constraints: blockConstraints,\n              fields: block.flattenedFields,\n              joins: newJoins,\n              locale,\n              parentIsLocalized: parentIsLocalized || field.localized,\n              pathSegments: pathSegments.slice(1),\n              rootTableName,\n              selectFields: blockSelectFields,\n              selectLocale,\n              tableName: newTableName,\n              value,\n            })\n          } catch (_) {\n            // this is fine, not every block will have the field\n          }\n          if (!result) {\n            return\n          }\n          blockTableColumn = result\n          constraints = constraints.concat(blockConstraints)\n          selectFields = { ...selectFields, ...blockSelectFields }\n\n          const previousLength = joins.length\n          joins.push(blockJoin)\n          // Append new joins AFTER the block join to prevent errors with missing FROM clause.\n          if (newJoins.length > previousLength) {\n            for (let i = previousLength; i < newJoins.length; i++) {\n              joins.push(newJoins[i])\n            }\n          }\n          return true\n        })\n        if (hasBlockField) {\n          return {\n            columnName: blockTableColumn.columnName,\n            constraints,\n            field: blockTableColumn.field,\n            pathSegments: pathSegments.slice(1),\n            rawColumn: blockTableColumn.rawColumn,\n            table: blockTableColumn.table,\n          }\n        }\n        break\n      }\n\n      case 'group': {\n        if (locale && isFieldLocalized && adapter.payload.config.localization) {\n          newTableName = `${tableName}${adapter.localesSuffix}`\n\n          let condition = eq(adapter.tables[tableName].id, adapter.tables[newTableName]._parentID)\n\n          if (locale !== 'all') {\n            condition = and(condition, eq(adapter.tables[newTableName]._locale, locale))\n          }\n\n          addJoinTable({\n            condition,\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix: `${columnPrefix}${field.name}_`,\n          constraintPath: `${constraintPath}${field.name}.`,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n          value,\n        })\n      }\n\n      case 'join': {\n        if (Array.isArray(field.collection)) {\n          throw new APIError('Not supported')\n        }\n\n        const newCollectionPath = pathSegments.slice(1).join('.')\n\n        if (field.hasMany) {\n          const relationTableName = `${adapter.tableNameMap.get(toSnakeCase(field.collection))}${adapter.relationshipsSuffix}`\n          const { newAliasTable: aliasRelationshipTable } = getTableAlias({\n            adapter,\n            tableName: relationTableName,\n          })\n\n          const relationshipField = getFieldByPath({\n            fields: adapter.payload.collections[field.collection].config.flattenedFields,\n            path: field.on,\n          })\n          if (!relationshipField) {\n            throw new APIError('Relationship was not found')\n          }\n\n          addJoinTable({\n            condition: and(\n              eq(\n                adapter.tables[rootTableName].id,\n                aliasRelationshipTable[\n                  `${(relationshipField.field as RelationshipField).relationTo as string}ID`\n                ],\n              ),\n              like(aliasRelationshipTable.path, field.on),\n            ),\n            joins,\n            queryPath: field.on,\n            table: aliasRelationshipTable,\n          })\n\n          if (newCollectionPath === 'id') {\n            return {\n              columnName: 'parent',\n              constraints,\n              field: {\n                name: 'id',\n                type: adapter.idType === 'uuid' ? 'text' : 'number',\n              } as NumberField | TextField,\n              table: aliasRelationshipTable,\n            }\n          }\n\n          const relationshipConfig = adapter.payload.collections[field.collection].config\n          const relationshipTableName = adapter.tableNameMap.get(\n            toSnakeCase(relationshipConfig.slug),\n          )\n\n          // parent to relationship join table\n          const relationshipFields = relationshipConfig.flattenedFields\n\n          const { newAliasTable: relationshipTable } = getTableAlias({\n            adapter,\n            tableName: relationshipTableName,\n          })\n\n          joins.push({\n            condition: eq(aliasRelationshipTable.parent, relationshipTable.id),\n            table: relationshipTable,\n          })\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: relationshipTable,\n            collectionPath: newCollectionPath,\n            constraints,\n            // relationshipFields are fields from a different collection => no parentIsLocalized\n            fields: relationshipFields,\n            joins,\n            locale,\n            parentIsLocalized: false,\n            pathSegments: pathSegments.slice(1),\n            rootTableName: relationshipTableName,\n            selectFields,\n            selectLocale,\n            tableName: relationshipTableName,\n            value,\n          })\n        }\n\n        const newTableName = adapter.tableNameMap.get(\n          toSnakeCase(adapter.payload.collections[field.collection].config.slug),\n        )\n        const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n        joins.push({\n          condition: eq(\n            newAliasTable[field.on.replaceAll('.', '_')],\n            aliasTable ? aliasTable.id : adapter.tables[tableName].id,\n          ),\n          table: newAliasTable,\n        })\n\n        if (newCollectionPath === 'id') {\n          return {\n            columnName: 'id',\n            constraints,\n            field: {\n              name: 'id',\n              type: adapter.idType === 'uuid' ? 'text' : 'number',\n            } as NumberField | TextField,\n            table: newAliasTable,\n          }\n        }\n\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable: newAliasTable,\n          collectionPath: newCollectionPath,\n          constraintPath: '',\n          constraints,\n          fields: adapter.payload.collections[field.collection].config.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          selectFields,\n          tableName: newTableName,\n          value,\n        })\n\n        break\n      }\n\n      case 'number':\n      case 'text': {\n        if (field.hasMany) {\n          let tableType = 'texts'\n          let columnName = 'text'\n          if (field.type === 'number') {\n            tableType = 'numbers'\n            columnName = 'number'\n          }\n          newTableName = `${rootTableName}_${tableType}`\n          const joinConstraints = [\n            eq(adapter.tables[rootTableName].id, adapter.tables[newTableName].parent),\n            like(adapter.tables[newTableName].path, `${constraintPath}${field.name}`),\n          ]\n\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [...joinConstraints]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            addJoinTable({\n              condition: and(...joinConstraints),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName,\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n      case 'relationship':\n      case 'upload': {\n        const newCollectionPath = pathSegments.slice(1).join('.')\n\n        if (Array.isArray(field.relationTo) || field.hasMany) {\n          let relationshipFields: FlattenedField[]\n          const relationTableName = `${rootTableName}${adapter.relationshipsSuffix}`\n          const {\n            newAliasTable: aliasRelationshipTable,\n            newAliasTableName: aliasRelationshipTableName,\n          } = getTableAlias({\n            adapter,\n            tableName: relationTableName,\n          })\n\n          if (selectLocale && isFieldLocalized && adapter.payload.config.localization) {\n            selectFields._locale = aliasRelationshipTable.locale\n          }\n\n          // Join in the relationships table\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq((aliasTable || adapter.tables[rootTableName]).id, aliasRelationshipTable.parent),\n              like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(aliasRelationshipTable.locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              queryPath: `${constraintPath}.${field.name}`,\n              table: aliasRelationshipTable,\n            })\n          } else {\n            // Join in the relationships table\n            addJoinTable({\n              condition: and(\n                eq((aliasTable || adapter.tables[rootTableName]).id, aliasRelationshipTable.parent),\n                like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n              ),\n              joins,\n              queryPath: `${constraintPath}.${field.name}`,\n              table: aliasRelationshipTable,\n            })\n          }\n\n          selectFields[`${relationTableName}.path`] = aliasRelationshipTable.path\n\n          let newAliasTable\n\n          if (typeof field.relationTo === 'string') {\n            const relationshipConfig = adapter.payload.collections[field.relationTo].config\n\n            newTableName = adapter.tableNameMap.get(toSnakeCase(relationshipConfig.slug))\n\n            // parent to relationship join table\n            relationshipFields = relationshipConfig.flattenedFields\n            ;({ newAliasTable } = getTableAlias({ adapter, tableName: newTableName }))\n\n            joins.push({\n              condition: eq(newAliasTable.id, aliasRelationshipTable[`${field.relationTo}ID`]),\n              table: newAliasTable,\n            })\n\n            if (newCollectionPath === '' || newCollectionPath === 'id') {\n              return {\n                columnName: `${field.relationTo}ID`,\n                constraints,\n                field,\n                table: aliasRelationshipTable,\n              }\n            }\n          } else if (newCollectionPath === 'value') {\n            const hasCustomCollectionWithCustomID = field.relationTo.some(\n              (relationTo) => !!adapter.payload.collections[relationTo].customIDType,\n            )\n\n            const columns: TableColumn['columns'] = field.relationTo\n              .map((relationTo) => {\n                let idType: 'number' | 'text' | 'uuid' =\n                  adapter.idType === 'uuid' ? 'uuid' : 'number'\n\n                const { customIDType } = adapter.payload.collections[relationTo]\n\n                if (customIDType) {\n                  idType = customIDType\n                }\n\n                const idTypeTextOrUuid = idType === 'text' || idType === 'uuid'\n\n                // Do not add the column to OR if we know that it can't match by the type\n                // We can't do the same with idType: 'number' because `value` can be from the REST search query params\n                if (typeof value === 'number' && idTypeTextOrUuid) {\n                  return null\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  value.every((val) => typeof val === 'number') &&\n                  idTypeTextOrUuid\n                ) {\n                  return null\n                }\n\n                // Do not add the UUID type column if incoming query value doesn't match UUID. If there aren't any collections with\n                // a custom ID type, we skip this check\n                // We need this because Postgres throws an error if querying by UUID column with a value that isn't a valid UUID.\n                if (\n                  value &&\n                  !Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID\n                ) {\n                  if (!uuidValidate(value)) {\n                    return null\n                  }\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID &&\n                  !value.some((val) => uuidValidate(val))\n                ) {\n                  return null\n                }\n\n                const relationTableName = adapter.tableNameMap.get(\n                  toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n                )\n\n                return {\n                  idType,\n                  rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n                }\n              })\n              .filter(Boolean)\n\n            return {\n              columns,\n              constraints,\n              field,\n              table: aliasRelationshipTable,\n            }\n          } else if (newCollectionPath === 'relationTo') {\n            const relationTo = Array.isArray(field.relationTo)\n              ? field.relationTo\n              : [field.relationTo]\n\n            return {\n              constraints,\n              field,\n              getNotNullColumnByValue: (val) => {\n                const matchedRelation = relationTo.find((relation) => relation === val)\n                if (matchedRelation) {\n                  return `${matchedRelation}ID`\n                }\n                return undefined\n              },\n              table: aliasRelationshipTable,\n            }\n          } else if (isPolymorphicRelationship(value)) {\n            const { relationTo } = value\n\n            const relationTableName = adapter.tableNameMap.get(\n              toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n            )\n\n            return {\n              constraints,\n              field,\n              rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n              table: aliasRelationshipTable,\n            }\n          } else {\n            throw new APIError('Not supported')\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraints,\n            // relationshipFields are fields from a different collection => no parentIsLocalized\n            fields: relationshipFields,\n            joins,\n            locale,\n            parentIsLocalized: false,\n            pathSegments: pathSegments.slice(1),\n            rootTableName: newTableName,\n            selectFields,\n            selectLocale,\n            tableName: newTableName,\n            value,\n          })\n        } else if (\n          pathSegments.length > 1 &&\n          !(pathSegments.length === 2 && pathSegments[1] === 'id')\n        ) {\n          // simple relationships\n          const columnName = `${columnPrefix}${field.name}`\n          const newTableName = adapter.tableNameMap.get(\n            toSnakeCase(adapter.payload.collections[field.relationTo].config.slug),\n          )\n          const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n          if (isFieldLocalized && adapter.payload.config.localization) {\n            const { newAliasTable: aliasLocaleTable } = getTableAlias({\n              adapter,\n              tableName: `${rootTableName}${adapter.localesSuffix}`,\n            })\n\n            const condtions = [eq(aliasLocaleTable._parentID, adapter.tables[rootTableName].id)]\n\n            if (selectLocale) {\n              selectFields._locale = aliasLocaleTable._locale\n            }\n\n            if (locale !== 'all') {\n              condtions.push(eq(aliasLocaleTable._locale, locale))\n            }\n\n            const localesTable = adapter.tables[`${rootTableName}${adapter.localesSuffix}`]\n\n            addJoinTable({\n              condition: and(...condtions),\n              joins,\n              table: localesTable,\n            })\n\n            joins.push({\n              condition: eq(localesTable[columnName], newAliasTable.id),\n              table: newAliasTable,\n            })\n          } else {\n            joins.push({\n              condition: eq(\n                newAliasTable.id,\n                aliasTable ? aliasTable[columnName] : adapter.tables[tableName][columnName],\n              ),\n              table: newAliasTable,\n            })\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraintPath: '',\n            constraints,\n            fields: adapter.payload.collections[field.relationTo].config.flattenedFields,\n            joins,\n            locale,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            pathSegments: pathSegments.slice(1),\n            selectFields,\n            tableName: newTableName,\n            value,\n          })\n        }\n\n        break\n      }\n\n      case 'select': {\n        if (field.hasMany) {\n          const newTableName = adapter.tableNameMap.get(\n            `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n          )\n\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(adapter.tables[tableName].id, adapter.tables[newTableName].parent),\n              eq(adapter.tables[newTableName]._locale, locale),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            addJoinTable({\n              condition: eq(adapter.tables[tableName].id, adapter.tables[newTableName].parent),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName: 'value',\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n\n      case 'tab': {\n        if (tabHasName(field)) {\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable,\n            collectionPath,\n            columnPrefix: `${columnPrefix}${field.name}_`,\n            constraintPath: `${constraintPath}${field.name}.`,\n            constraints,\n            fields: field.flattenedFields,\n            joins,\n            locale,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            pathSegments: pathSegments.slice(1),\n            rootTableName,\n            selectFields,\n            selectLocale,\n            tableName: newTableName,\n            tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n            value,\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix,\n          constraintPath,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          tableNameSuffix,\n          value,\n        })\n      }\n\n      default: {\n        // fall through\n        break\n      }\n    }\n\n    let newTable = adapter.tables[newTableName]\n\n    if (isFieldLocalized && adapter.payload.config.localization) {\n      // If localized, we go to localized table and set aliasTable to undefined\n      // so it is not picked up below to be used as targetTable\n      const parentTable = aliasTable || adapter.tables[tableName]\n      newTableName = `${tableName}${adapter.localesSuffix}`\n\n      newTable = adapter.tables[newTableName]\n\n      let condition = eq(parentTable.id, newTable._parentID)\n\n      if (locale !== 'all') {\n        condition = and(condition, eq(newTable._locale, locale))\n      }\n\n      if (selectLocale) {\n        selectFields._locale = newTable._locale\n      }\n\n      addJoinTable({\n        condition,\n        joins,\n        table: newTable,\n      })\n\n      aliasTable = undefined\n    }\n\n    const targetTable = aliasTable || newTable\n\n    selectFields[`${newTableName}.${columnPrefix}${field.name}`] =\n      targetTable[`${columnPrefix}${field.name}`]\n\n    return {\n      columnName: `${columnPrefix}${field.name}`,\n      constraints,\n      field,\n      pathSegments,\n      table: targetTable,\n    }\n  }\n\n  throw new APIError(`Cannot find field for path at ${fieldPath}`)\n}\n"],"names":["and","eq","like","sql","APIError","getFieldByPath","fieldShouldBeLocalized","tabHasName","toSnakeCase","validate","uuidValidate","isPolymorphicRelationship","resolveBlockTableName","addJoinTable","getTableAlias","getTableColumnFromPath","adapter","aliasTable","collectionPath","columnPrefix","constraintPath","incomingConstraintPath","constraints","fields","joins","locale","incomingLocale","parentIsLocalized","pathSegments","incomingSegments","rootTableName","incomingRootTableName","selectFields","selectLocale","tableName","tableNameSuffix","value","fieldPath","field","find","fieldToFind","name","newTableName","id","tables","columnName","type","idType","table","isFieldLocalized","payload","config","localization","matchedLocale","localeCodes","splice","tableNameMap","get","arrayParentTable","conditions","_parentID","_locale","push","condition","flattenedFields","localized","slice","blocksAsJSON","blockTableColumn","blockTypes","Array","isArray","forEach","blockType","block","blocks","blockReferences","slug","newAliasTable","getNotNullColumnByValue","hasBlockField","some","_block","result","blockConstraints","blockSelectFields","blockJoin","newJoins","_","concat","previousLength","length","i","rawColumn","localesSuffix","collection","newCollectionPath","join","hasMany","relationTableName","relationshipsSuffix","aliasRelationshipTable","relationshipField","collections","path","on","relationTo","queryPath","relationshipConfig","relationshipTableName","relationshipFields","relationshipTable","parent","replaceAll","tableType","joinConstraints","newAliasTableName","aliasRelationshipTableName","hasCustomCollectionWithCustomID","customIDType","columns","map","idTypeTextOrUuid","every","val","raw","filter","Boolean","matchedRelation","relation","undefined","aliasLocaleTable","condtions","localesTable","newTable","parentTable","targetTable"],"mappings":"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"}