{"version":3,"sources":["../../src/upsertRow/index.ts"],"sourcesContent":["import type { TypeWithID } from 'payload'\n\nimport { eq } from 'drizzle-orm'\nimport { ValidationError } from 'payload'\n\nimport type { BlockRowToInsert } from '../transform/write/types.js'\nimport type { Args } from './types.js'\n\nimport { buildFindManyArgs } from '../find/buildFindManyArgs.js'\nimport { transform } from '../transform/read/index.js'\nimport { transformForWrite } from '../transform/write/index.js'\nimport { deleteExistingArrayRows } from './deleteExistingArrayRows.js'\nimport { deleteExistingRowsByPath } from './deleteExistingRowsByPath.js'\nimport { insertArrays } from './insertArrays.js'\n\nexport const upsertRow = async <T extends Record<string, unknown> | TypeWithID>({\n  id,\n  adapter,\n  data,\n  db,\n  fields,\n  ignoreResult,\n  // TODO:\n  // When we support joins for write operations (create/update) - pass collectionSlug to the buildFindManyArgs\n  // Make a new argument in upsertRow.ts and pass the slug from every operation.\n  joinQuery: _joinQuery,\n  operation,\n  path = '',\n  req,\n  select,\n  tableName,\n  upsertTarget,\n  where,\n}: Args): Promise<T> => {\n  // Split out the incoming data into the corresponding:\n  // base row, locales, relationships, blocks, and arrays\n  const rowToInsert = transformForWrite({\n    adapter,\n    data,\n    fields,\n    path,\n    tableName,\n  })\n\n  // First, we insert the main row\n  let insertedRow: Record<string, unknown>\n\n  try {\n    if (operation === 'update') {\n      const target = upsertTarget || adapter.tables[tableName].id\n\n      if (id) {\n        rowToInsert.row.id = id\n        ;[insertedRow] = await adapter.insert({\n          db,\n          onConflictDoUpdate: { set: rowToInsert.row, target },\n          tableName,\n          values: rowToInsert.row,\n        })\n      } else {\n        ;[insertedRow] = await adapter.insert({\n          db,\n          onConflictDoUpdate: { set: rowToInsert.row, target, where },\n          tableName,\n          values: rowToInsert.row,\n        })\n      }\n    } else {\n      if (adapter.allowIDOnCreate && data.id) {\n        rowToInsert.row.id = data.id\n      }\n      ;[insertedRow] = await adapter.insert({\n        db,\n        tableName,\n        values: rowToInsert.row,\n      })\n    }\n\n    const localesToInsert: Record<string, unknown>[] = []\n    const relationsToInsert: Record<string, unknown>[] = []\n    const textsToInsert: Record<string, unknown>[] = []\n    const numbersToInsert: Record<string, unknown>[] = []\n    const blocksToInsert: { [blockType: string]: BlockRowToInsert[] } = {}\n    const selectsToInsert: { [selectTableName: string]: Record<string, unknown>[] } = {}\n\n    // If there are locale rows with data, add the parent and locale to each\n    if (Object.keys(rowToInsert.locales).length > 0) {\n      Object.entries(rowToInsert.locales).forEach(([locale, localeRow]) => {\n        localeRow._parentID = insertedRow.id\n        localeRow._locale = locale\n        localesToInsert.push(localeRow)\n      })\n    }\n\n    // If there are relationships, add parent to each\n    if (rowToInsert.relationships.length > 0) {\n      rowToInsert.relationships.forEach((relation) => {\n        relation.parent = insertedRow.id\n        relationsToInsert.push(relation)\n      })\n    }\n\n    // If there are texts, add parent to each\n    if (rowToInsert.texts.length > 0) {\n      rowToInsert.texts.forEach((textRow) => {\n        textRow.parent = insertedRow.id\n        textsToInsert.push(textRow)\n      })\n    }\n\n    // If there are numbers, add parent to each\n    if (rowToInsert.numbers.length > 0) {\n      rowToInsert.numbers.forEach((numberRow) => {\n        numberRow.parent = insertedRow.id\n        numbersToInsert.push(numberRow)\n      })\n    }\n\n    // If there are selects, add parent to each, and then\n    // store by table name and rows\n    if (Object.keys(rowToInsert.selects).length > 0) {\n      Object.entries(rowToInsert.selects).forEach(([selectTableName, selectRows]) => {\n        selectsToInsert[selectTableName] = []\n\n        selectRows.forEach((row) => {\n          if (typeof row.parent === 'undefined') {\n            row.parent = insertedRow.id\n          }\n\n          selectsToInsert[selectTableName].push(row)\n        })\n      })\n    }\n\n    // If there are blocks, add parent to each, and then\n    // store by table name and rows\n    Object.keys(rowToInsert.blocks).forEach((tableName) => {\n      rowToInsert.blocks[tableName].forEach((blockRow) => {\n        blockRow.row._parentID = insertedRow.id\n        if (!blocksToInsert[tableName]) {\n          blocksToInsert[tableName] = []\n        }\n        if (blockRow.row.uuid) {\n          delete blockRow.row.uuid\n        }\n        blocksToInsert[tableName].push(blockRow)\n      })\n    })\n\n    // //////////////////////////////////\n    // INSERT LOCALES\n    // //////////////////////////////////\n\n    if (localesToInsert.length > 0) {\n      const localeTableName = `${tableName}${adapter.localesSuffix}`\n      const localeTable = adapter.tables[`${tableName}${adapter.localesSuffix}`]\n\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: localeTableName,\n          where: eq(localeTable._parentID, insertedRow.id),\n        })\n      }\n\n      await adapter.insert({\n        db,\n        tableName: localeTableName,\n        values: localesToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT RELATIONSHIPS\n    // //////////////////////////////////\n\n    const relationshipsTableName = `${tableName}${adapter.relationshipsSuffix}`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...relationsToInsert, ...rowToInsert.relationshipsToDelete],\n        tableName: relationshipsTableName,\n      })\n    }\n\n    if (relationsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: relationshipsTableName,\n        values: relationsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany TEXTS\n    // //////////////////////////////////\n\n    const textsTableName = `${tableName}_texts`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...textsToInsert, ...rowToInsert.textsToDelete],\n        tableName: textsTableName,\n      })\n    }\n\n    if (textsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: textsTableName,\n        values: textsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany NUMBERS\n    // //////////////////////////////////\n\n    const numbersTableName = `${tableName}_numbers`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...numbersToInsert, ...rowToInsert.numbersToDelete],\n        tableName: numbersTableName,\n      })\n    }\n\n    if (numbersToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: numbersTableName,\n        values: numbersToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT BLOCKS\n    // //////////////////////////////////\n\n    const insertedBlockRows: Record<string, Record<string, unknown>[]> = {}\n\n    if (operation === 'update') {\n      for (const tableName of rowToInsert.blocksToDelete) {\n        const blockTable = adapter.tables[tableName]\n        await adapter.deleteWhere({\n          db,\n          tableName,\n          where: eq(blockTable._parentID, insertedRow.id),\n        })\n      }\n    }\n\n    // When versions are enabled, this is used to track mapping between blocks/arrays ObjectID to their numeric generated representation, then we use it for nested to arrays/blocks select hasMany in versions.\n    const arraysBlocksUUIDMap: Record<string, number | string> = {}\n\n    for (const [tableName, blockRows] of Object.entries(blocksToInsert)) {\n      insertedBlockRows[tableName] = await adapter.insert({\n        db,\n        tableName,\n        values: blockRows.map(({ row }) => row),\n      })\n\n      insertedBlockRows[tableName].forEach((row, i) => {\n        blockRows[i].row = row\n        if (\n          typeof row._uuid === 'string' &&\n          (typeof row.id === 'string' || typeof row.id === 'number')\n        ) {\n          arraysBlocksUUIDMap[row._uuid] = row.id\n        }\n      })\n\n      const blockLocaleIndexMap: number[] = []\n\n      const blockLocaleRowsToInsert = blockRows.reduce((acc, blockRow, i) => {\n        if (Object.entries(blockRow.locales).length > 0) {\n          Object.entries(blockRow.locales).forEach(([blockLocale, blockLocaleData]) => {\n            if (Object.keys(blockLocaleData).length > 0) {\n              blockLocaleData._parentID = blockRow.row.id\n              blockLocaleData._locale = blockLocale\n              acc.push(blockLocaleData)\n              blockLocaleIndexMap.push(i)\n            }\n          })\n        }\n\n        return acc\n      }, [])\n\n      if (blockLocaleRowsToInsert.length > 0) {\n        await adapter.insert({\n          db,\n          tableName: `${tableName}${adapter.localesSuffix}`,\n          values: blockLocaleRowsToInsert,\n        })\n      }\n\n      await insertArrays({\n        adapter,\n        arrays: blockRows.map(({ arrays }) => arrays),\n        db,\n        parentRows: insertedBlockRows[tableName],\n        uuidMap: arraysBlocksUUIDMap,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT ARRAYS RECURSIVELY\n    // //////////////////////////////////\n\n    if (operation === 'update') {\n      for (const arrayTableName of Object.keys(rowToInsert.arrays)) {\n        await deleteExistingArrayRows({\n          adapter,\n          db,\n          parentID: insertedRow.id,\n          tableName: arrayTableName,\n        })\n      }\n    }\n\n    await insertArrays({\n      adapter,\n      arrays: [rowToInsert.arrays],\n      db,\n      parentRows: [insertedRow],\n      uuidMap: arraysBlocksUUIDMap,\n    })\n\n    // //////////////////////////////////\n    // INSERT hasMany SELECTS\n    // //////////////////////////////////\n\n    for (const [selectTableName, tableRows] of Object.entries(selectsToInsert)) {\n      const selectTable = adapter.tables[selectTableName]\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: selectTableName,\n          where: eq(selectTable.parent, insertedRow.id),\n        })\n      }\n\n      if (Object.keys(arraysBlocksUUIDMap).length > 0) {\n        tableRows.forEach((row: any) => {\n          if (row.parent in arraysBlocksUUIDMap) {\n            row.parent = arraysBlocksUUIDMap[row.parent]\n          }\n        })\n      }\n\n      if (tableRows.length) {\n        await adapter.insert({\n          db,\n          tableName: selectTableName,\n          values: tableRows,\n        })\n      }\n    }\n\n    // //////////////////////////////////\n    // Error Handling\n    // //////////////////////////////////\n  } catch (caughtError) {\n    // Unique constraint violation error\n    // '23505' is the code for PostgreSQL, and 'SQLITE_CONSTRAINT_UNIQUE' is for SQLite\n\n    let error = caughtError\n    if (typeof caughtError === 'object' && 'cause' in caughtError) {\n      error = caughtError.cause\n    }\n\n    if (error.code === '23505' || error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\n      let fieldName: null | string = null\n      // We need to try and find the right constraint for the field but if we can't we fallback to a generic message\n      if (error.code === '23505') {\n        // For PostgreSQL, we can try to extract the field name from the error constraint\n        if (adapter.fieldConstraints?.[tableName]?.[error.constraint]) {\n          fieldName = adapter.fieldConstraints[tableName]?.[error.constraint]\n        } else {\n          const replacement = `${tableName}_`\n\n          if (error.constraint.includes(replacement)) {\n            const replacedConstraint = error.constraint.replace(replacement, '')\n\n            if (replacedConstraint && adapter.fieldConstraints[tableName]?.[replacedConstraint]) {\n              fieldName = adapter.fieldConstraints[tableName][replacedConstraint]\n            }\n          }\n        }\n\n        if (!fieldName) {\n          // Last case scenario we extract the key and value from the detail on the error\n          const detail = error.detail\n          const regex = /Key \\(([^)]+)\\)=\\(([^)]+)\\)/\n          const match: string[] = detail.match(regex)\n\n          if (match && match[1]) {\n            const key = match[1]\n\n            fieldName = key\n          }\n        }\n      } else if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\n        /**\n         * For SQLite, we can try to extract the field name from the error message\n         * The message typically looks like:\n         * \"UNIQUE constraint failed: table_name.field_name\"\n         */\n        const regex = /UNIQUE constraint failed: ([^.]+)\\.([^.]+)/\n        const match: string[] = error.message.match(regex)\n\n        if (match && match[2]) {\n          if (adapter.fieldConstraints[tableName]) {\n            fieldName = adapter.fieldConstraints[tableName][`${match[2]}_idx`]\n          }\n\n          if (!fieldName) {\n            fieldName = match[2]\n          }\n        }\n      }\n\n      throw new ValidationError(\n        {\n          id,\n          errors: [\n            {\n              message: req?.t ? req.t('error:valueMustBeUnique') : 'Value must be unique',\n              path: fieldName,\n            },\n          ],\n          req,\n        },\n        req?.t,\n      )\n    } else {\n      throw error\n    }\n  }\n\n  if (ignoreResult === 'idOnly') {\n    return { id: insertedRow.id } as T\n  }\n\n  if (ignoreResult) {\n    return data as T\n  }\n\n  // //////////////////////////////////\n  // RETRIEVE NEWLY UPDATED ROW\n  // //////////////////////////////////\n\n  const findManyArgs = buildFindManyArgs({\n    adapter,\n    depth: 0,\n    fields,\n    joinQuery: false,\n    select,\n    tableName,\n  })\n\n  findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n  const doc = await db.query[tableName].findFirst(findManyArgs)\n\n  // //////////////////////////////////\n  // TRANSFORM DATA\n  // //////////////////////////////////\n\n  const result = transform<T>({\n    adapter,\n    config: adapter.payload.config,\n    data: doc,\n    fields,\n    joinQuery: false,\n    tableName,\n  })\n\n  return result\n}\n"],"names":["eq","ValidationError","buildFindManyArgs","transform","transformForWrite","deleteExistingArrayRows","deleteExistingRowsByPath","insertArrays","upsertRow","id","adapter","data","db","fields","ignoreResult","joinQuery","_joinQuery","operation","path","req","select","tableName","upsertTarget","where","rowToInsert","insertedRow","target","tables","row","insert","onConflictDoUpdate","set","values","allowIDOnCreate","localesToInsert","relationsToInsert","textsToInsert","numbersToInsert","blocksToInsert","selectsToInsert","Object","keys","locales","length","entries","forEach","locale","localeRow","_parentID","_locale","push","relationships","relation","parent","texts","textRow","numbers","numberRow","selects","selectTableName","selectRows","blocks","blockRow","uuid","localeTableName","localesSuffix","localeTable","deleteWhere","relationshipsTableName","relationshipsSuffix","localeColumnName","parentColumnName","parentID","pathColumnName","rows","relationshipsToDelete","textsTableName","textsToDelete","numbersTableName","numbersToDelete","insertedBlockRows","blocksToDelete","blockTable","arraysBlocksUUIDMap","blockRows","map","i","_uuid","blockLocaleIndexMap","blockLocaleRowsToInsert","reduce","acc","blockLocale","blockLocaleData","arrays","parentRows","uuidMap","arrayTableName","tableRows","selectTable","caughtError","error","cause","code","fieldName","fieldConstraints","constraint","replacement","includes","replacedConstraint","replace","detail","regex","match","key","message","errors","t","findManyArgs","depth","doc","query","findFirst","result","config","payload"],"mappings":"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"}