{"version":3,"sources":["../../src/uploads/safeFetch.ts"],"sourcesContent":["import type { Dispatcher } from 'undici'\n\nimport ipaddr from 'ipaddr.js'\nimport { Agent, fetch as undiciFetch } from 'undici'\n\nconst isSafeIp = (ip: string) => {\n  try {\n    if (!ip) {\n      return false\n    }\n\n    if (!ipaddr.isValid(ip)) {\n      return false\n    }\n\n    const parsedIpAddress = ipaddr.parse(ip)\n    const range = parsedIpAddress.range()\n    if (range !== 'unicast') {\n      return false // Private IP Range\n    }\n  } catch (ignore) {\n    return false\n  }\n  return true\n}\n\nconst ssrfFilterInterceptor: Dispatcher.DispatcherComposeInterceptor = (dispatch) => {\n  return (opts, handler) => {\n    const url = new URL(opts.origin?.toString() + opts.path)\n    if (!isSafeIp(url.hostname)) {\n      throw new Error(`Blocked unsafe attempt to ${url}`)\n    }\n    return dispatch(opts, handler)\n  }\n}\n\nconst safeDispatcher = new Agent().compose(ssrfFilterInterceptor)\n\n/**\n * A \"safe\" version of undici's fetch that prevents SSRF attacks.\n *\n * - Utilizes a custom dispatcher that filters out requests to unsafe IP addresses.\n * - Undici was used because it supported interceptors as well as \"credentials: include\". Native fetch\n */\nexport const safeFetch = async (...args: Parameters<typeof undiciFetch>) => {\n  const [url, options] = args\n  try {\n    return await undiciFetch(url, {\n      ...options,\n      dispatcher: safeDispatcher,\n    })\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.cause instanceof Error && error.cause.message.includes('unsafe')) {\n        // Errors thrown from within interceptors always have 'fetch error' as the message\n        // The desired message we want to bubble up is in the cause\n        throw new Error(error.cause.message)\n      } else {\n        let stringifiedUrl: string | undefined | URL = undefined\n        if (typeof url === 'string' || url instanceof URL) {\n          stringifiedUrl = url\n        } else if (url instanceof Request) {\n          stringifiedUrl = url.url\n        }\n\n        throw new Error(`Failed to fetch from ${stringifiedUrl}, ${error.message}`)\n      }\n    }\n    throw error\n  }\n}\n"],"names":["ipaddr","Agent","fetch","undiciFetch","isSafeIp","ip","isValid","parsedIpAddress","parse","range","ignore","ssrfFilterInterceptor","dispatch","opts","handler","url","URL","origin","toString","path","hostname","Error","safeDispatcher","compose","safeFetch","args","options","dispatcher","error","cause","message","includes","stringifiedUrl","undefined","Request"],"mappings":"AAEA,OAAOA,YAAY,YAAW;AAC9B,SAASC,KAAK,EAAEC,SAASC,WAAW,QAAQ,SAAQ;AAEpD,MAAMC,WAAW,CAACC;IAChB,IAAI;QACF,IAAI,CAACA,IAAI;YACP,OAAO;QACT;QAEA,IAAI,CAACL,OAAOM,OAAO,CAACD,KAAK;YACvB,OAAO;QACT;QAEA,MAAME,kBAAkBP,OAAOQ,KAAK,CAACH;QACrC,MAAMI,QAAQF,gBAAgBE,KAAK;QACnC,IAAIA,UAAU,WAAW;YACvB,OAAO,MAAM,mBAAmB;;QAClC;IACF,EAAE,OAAOC,QAAQ;QACf,OAAO;IACT;IACA,OAAO;AACT;AAEA,MAAMC,wBAAiE,CAACC;IACtE,OAAO,CAACC,MAAMC;QACZ,MAAMC,MAAM,IAAIC,IAAIH,KAAKI,MAAM,EAAEC,aAAaL,KAAKM,IAAI;QACvD,IAAI,CAACf,SAASW,IAAIK,QAAQ,GAAG;YAC3B,MAAM,IAAIC,MAAM,CAAC,0BAA0B,EAAEN,KAAK;QACpD;QACA,OAAOH,SAASC,MAAMC;IACxB;AACF;AAEA,MAAMQ,iBAAiB,IAAIrB,QAAQsB,OAAO,CAACZ;AAE3C;;;;;CAKC,GACD,OAAO,MAAMa,YAAY,OAAO,GAAGC;IACjC,MAAM,CAACV,KAAKW,QAAQ,GAAGD;IACvB,IAAI;QACF,OAAO,MAAMtB,YAAYY,KAAK;YAC5B,GAAGW,OAAO;YACVC,YAAYL;QACd;IACF,EAAE,OAAOM,OAAO;QACd,IAAIA,iBAAiBP,OAAO;YAC1B,IAAIO,MAAMC,KAAK,YAAYR,SAASO,MAAMC,KAAK,CAACC,OAAO,CAACC,QAAQ,CAAC,WAAW;gBAC1E,kFAAkF;gBAClF,2DAA2D;gBAC3D,MAAM,IAAIV,MAAMO,MAAMC,KAAK,CAACC,OAAO;YACrC,OAAO;gBACL,IAAIE,iBAA2CC;gBAC/C,IAAI,OAAOlB,QAAQ,YAAYA,eAAeC,KAAK;oBACjDgB,iBAAiBjB;gBACnB,OAAO,IAAIA,eAAemB,SAAS;oBACjCF,iBAAiBjB,IAAIA,GAAG;gBAC1B;gBAEA,MAAM,IAAIM,MAAM,CAAC,qBAAqB,EAAEW,eAAe,EAAE,EAAEJ,MAAME,OAAO,EAAE;YAC5E;QACF;QACA,MAAMF;IACR;AACF,EAAC"}